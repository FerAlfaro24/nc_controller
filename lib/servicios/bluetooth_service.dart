import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:permission_handler/permission_handler.dart';

enum BluetoothConnectionState {
  disconnected,
  connecting,
  connected,
  error,
}

enum BluetoothDeviceType {
  classic, // HC-05, HC-06
  ble,     // Bluetooth Low Energy
  unknown, // Para dispositivos que no sabemos el tipo
}

class BluetoothDevice {
  final String name;
  final String address;
  final BluetoothDeviceType type;
  final int? rssi;
  final bool isConnected;
  final bool isPaired; // Para saber si est√° emparejado

  BluetoothDevice({
    required this.name,
    required this.address,
    required this.type,
    this.rssi,
    this.isConnected = false,
    this.isPaired = false,
  });

  // M√©todo para detectar si es HC-05/HC-06
  bool get isHcModule => name.toLowerCase().contains('hc-') ||
      name.toLowerCase().contains('bt-') ||
      address.startsWith('98:D3') || // Com√∫n en HC-05 clones
      address.startsWith('00:14:03'); // Otro MAC com√∫n

  @override
  String toString() => 'BluetoothDevice(name: $name, address: $address, type: $type, paired: $isPaired)';
}

// Comandos para controlar las figuras
class ComandosBluetooth {
  // LEDs - Mantenemos "1" para encender y "0" para apagar
  static const String LED_ENCENDER = "1";
  static const String LED_APAGAR = "0";

  // Para m√∫ltiples LEDs, usamos el formato: LED[n√∫mero][estado]
  static String ledComando(int numeroLed, bool encender) {
    return "LED${numeroLed}${encender ? '1' : '0'}";
  }

  // M√∫sica - Comandos para reproducir canciones
  static const String MUSICA_PLAY = "PLAY";
  static const String MUSICA_STOP = "STOP";
  static const String MUSICA_PAUSE = "PAUSE";
  static const String MUSICA_NEXT = "NEXT";
  static const String MUSICA_PREV = "PREV";

  // Para canci√≥n espec√≠fica: SONG[n√∫mero]
  static String reproducirCancion(int numeroCancion) {
    return "SONG$numeroCancion";
  }

  // Humidificador/Humo
  static const String HUMO_ENCENDER = "SMOKE1";
  static const String HUMO_APAGAR = "SMOKE0";

  // Comando de estado para obtener informaci√≥n del dispositivo
  static const String OBTENER_ESTADO = "STATUS";

  // Comando de prueba de conexi√≥n
  static const String TEST_CONEXION = "PING";
}

class BluetoothService {
  static final BluetoothService _instance = BluetoothService._internal();
  factory BluetoothService() => _instance;
  BluetoothService._internal();

  static const MethodChannel _methodChannel = MethodChannel('nc_bluetooth');

  // Streams para estado
  final StreamController<BluetoothConnectionState> _connectionStateController =
  StreamController<BluetoothConnectionState>.broadcast();
  final StreamController<List<BluetoothDevice>> _devicesController =
  StreamController<List<BluetoothDevice>>.broadcast();
  final StreamController<String> _dataController =
  StreamController<String>.broadcast();

  // Estado actual
  BluetoothConnectionState _currentState = BluetoothConnectionState.disconnected;
  BluetoothDevice? _connectedDevice;
  List<BluetoothDevice> _discoveredDevices = [];

  // üÜï NUEVO: Para pasar el nombre del dispositivo objetivo
  String? _targetDeviceName;

  // Getters para streams
  Stream<BluetoothConnectionState> get connectionState => _connectionStateController.stream;
  Stream<List<BluetoothDevice>> get discoveredDevices => _devicesController.stream;
  Stream<String> get dataReceived => _dataController.stream;

  // Getters para estado
  BluetoothConnectionState get currentState => _currentState;
  BluetoothDevice? get connectedDevice => _connectedDevice;
  bool get isConnected => _currentState == BluetoothConnectionState.connected;

  /// üÜï NUEVO: Configurar el nombre del dispositivo objetivo
  void setTargetDeviceName(String targetName) {
    _targetDeviceName = targetName;
    print('üéØ Nombre del dispositivo objetivo configurado: $_targetDeviceName');
  }

  /// Inicializar el servicio de Bluetooth
  Future<bool> initialize() async {
    try {
      print('üîµ Inicializando servicio Bluetooth...');

      // Verificar permisos
      if (!await _requestPermissions()) {
        print('‚ùå Permisos de Bluetooth denegados');
        return false;
      }

      // Verificar si Bluetooth est√° habilitado
      if (!await isBluetoothEnabled()) {
        print('‚ùå Bluetooth no est√° habilitado');
        return false;
      }

      // Configurar listeners de m√©todos nativos
      _methodChannel.setMethodCallHandler(_handleMethodCall);

      print('‚úÖ Servicio Bluetooth inicializado');
      return true;
    } catch (e) {
      print('‚ùå Error inicializando Bluetooth: $e');
      return false;
    }
  }

  /// Solicitar permisos de Bluetooth
  Future<bool> _requestPermissions() async {
    try {
      if (Platform.isAndroid) {
        // Solicitar todos los permisos necesarios a la vez.
        Map<Permission, PermissionStatus> statuses = await [
          Permission.bluetoothScan,
          Permission.bluetoothConnect,
          Permission.location,
        ].request();

        // Verificar que los permisos cr√≠ticos para la b√∫squeda y conexi√≥n fueron concedidos.
        final scanGranted = statuses[Permission.bluetoothScan]?.isGranted ?? false;
        final connectGranted = statuses[Permission.bluetoothConnect]?.isGranted ?? false;
        final locationGranted = statuses[Permission.location]?.isGranted ?? false;

        print('üîµ Verificaci√≥n de Permisos:');
        print('   - B√∫squeda (Scan): ${scanGranted ? 'CONCEDIDO' : 'DENEGADO'}');
        print('   - Conexi√≥n (Connect): ${connectGranted ? 'CONCEDIDO' : 'DENEGADO'}');
        print('   - Ubicaci√≥n (Location): ${locationGranted ? 'CONCEDIDO' : 'DENEGADO'}');

        if (!scanGranted || !connectGranted) {
          print('‚ùå Permisos de Bluetooth (Scan o Connect) denegados. No se puede continuar.');
          return false;
        }
        if(!locationGranted) {
          print('‚ùå Permiso de Ubicaci√≥n denegado. Es necesario para buscar dispositivos.');
          return false;
        }
      }
      return true;
    } catch (e) {
      print('‚ùå Error fatal solicitando permisos: $e');
      return false;
    }
  }

  /// Verificar si Bluetooth est√° habilitado
  Future<bool> isBluetoothEnabled() async {
    try {
      return await _methodChannel.invokeMethod('isBluetoothEnabled') ?? false;
    } catch (e) {
      print('‚ùå Error verificando Bluetooth: $e');
      return false;
    }
  }

  /// Solicitar habilitar Bluetooth
  Future<bool> enableBluetooth() async {
    try {
      return await _methodChannel.invokeMethod('enableBluetooth') ?? false;
    } catch (e) {
      print('‚ùå Error habilitando Bluetooth: $e');
      return false;
    }
  }

  /// Obtener dispositivos emparejados
  Future<List<BluetoothDevice>> getPairedDevices() async {
    try {
      print('üì± Obteniendo dispositivos emparejados...');
      final result = await _methodChannel.invokeMethod('getPairedDevices');

      if (result != null && result is List) {
        List<BluetoothDevice> pairedDevices = [];

        for (var deviceData in result) {
          final device = BluetoothDevice(
            name: deviceData['name'] ?? 'Dispositivo desconocido',
            address: deviceData['address'] ?? '',
            type: BluetoothDeviceType.classic, // Los emparejados suelen ser cl√°sicos
            isPaired: true,
          );
          pairedDevices.add(device);
          print('üì± Dispositivo emparejado: ${device.name} (${device.address})');
        }

        return pairedDevices;
      }

      return [];
    } catch (e) {
      print('‚ùå Error obteniendo dispositivos emparejados: $e');
      return [];
    }
  }

  /// Escanear dispositivos Bluetooth
  Future<bool> startDiscovery({BluetoothDeviceType? deviceType}) async {
    try {
      print('üîç Iniciando b√∫squeda de dispositivos...');
      _discoveredDevices.clear();

      // Primero obtener dispositivos emparejados
      final pairedDevices = await getPairedDevices();
      _discoveredDevices.addAll(pairedDevices);
      _devicesController.add(List.from(_discoveredDevices));

      final success = await _methodChannel.invokeMethod('startDiscovery', {
        'deviceType': deviceType?.toString() ?? 'both',
      });

      return success ?? false;
    } catch (e) {
      print('‚ùå Error iniciando b√∫squeda: $e');
      return false;
    }
  }

  /// Detener escaneo
  Future<bool> stopDiscovery() async {
    try {
      return await _methodChannel.invokeMethod('stopDiscovery') ?? false;
    } catch (e) {
      print('‚ùå Error deteniendo b√∫squeda: $e');
      return false;
    }
  }

  /// üöÄ CONEXI√ìN MEJORADA que usa la misma l√≥gica que el cartel "COMPATIBLE"
  Future<bool> connectToDevice(BluetoothDevice device) async {
    try {
      print('üîó Conectando a ${device.name} (${device.address})...');
      _updateConnectionState(BluetoothConnectionState.connecting);

      // üÜï DETERMINAR si es dispositivo compatible (mismo criterio que el cartel verde)
      bool isTargetDevice = false;
      if (_targetDeviceName != null && _targetDeviceName!.isNotEmpty) {
        isTargetDevice = device.name.toLowerCase().contains(_targetDeviceName!.toLowerCase());
        print('üéØ Dispositivo objetivo: ${isTargetDevice ? 'S√ç' : 'NO'} (buscando: $_targetDeviceName en: ${device.name})');
      }

      final success = await _connectWithType(device, device.type, isTargetDevice);

      if (success) {
        _connectedDevice = device;
        _updateConnectionState(BluetoothConnectionState.connected);
        print('‚úÖ Conectado a ${device.name}');

        // Enviar comando de prueba
        await Future.delayed(const Duration(milliseconds: 500));
        await sendCommand(ComandosBluetooth.TEST_CONEXION);
      } else {
        _updateConnectionState(BluetoothConnectionState.error);
        print('‚ùå Fall√≥ la conexi√≥n a ${device.name}');
      }

      return success;
    } catch (e) {
      print('‚ùå Error conectando: $e');
      _updateConnectionState(BluetoothConnectionState.error);
      return false;
    }
  }

  /// üÜï Conectar con informaci√≥n de si es dispositivo objetivo
  Future<bool> _connectWithType(BluetoothDevice device, BluetoothDeviceType type, bool isTargetDevice) async {
    try {
      final success = await _methodChannel.invokeMethod('connectToDevice', {
        'address': device.address,
        'type': type.toString().split('.').last,
        'targetDeviceName': isTargetDevice ? _targetDeviceName : null, // üÜï NUEVO par√°metro
      });

      return success ?? false;
    } catch (e) {
      print('‚ùå Error conectando con tipo $type: $e');
      return false;
    }
  }

  /// Desconectar dispositivo actual
  Future<bool> disconnect() async {
    try {
      print('üîå Desconectando...');

      final success = await _methodChannel.invokeMethod('disconnect');

      if (success == true) {
        _connectedDevice = null;
        _updateConnectionState(BluetoothConnectionState.disconnected);
        print('‚úÖ Desconectado');
      }

      return success ?? false;
    } catch (e) {
      print('‚ùå Error desconectando: $e');
      return false;
    }
  }

  /// Enviar comando al dispositivo conectado
  Future<bool> sendCommand(String command) async {
    if (!isConnected) {
      print('‚ùå No hay dispositivo conectado');
      return false;
    }

    try {
      print('üì§ Enviando comando: $command');

      // Para HC-05, agregar terminador de l√≠nea si no lo tiene
      String commandToSend = command;
      if (_connectedDevice?.isHcModule == true && !command.endsWith('\n')) {
        commandToSend = '$command\n';
      }

      final success = await _methodChannel.invokeMethod('sendData', {
        'data': commandToSend,
      });

      if (success == true) {
        print('‚úÖ Comando enviado: $commandToSend');
      } else {
        print('‚ùå Error enviando comando: $commandToSend');
      }

      return success ?? false;
    } catch (e) {
      print('‚ùå Error enviando comando $command: $e');
      return false;
    }
  }

  /// M√©todos espec√≠ficos para controlar componentes

  // Control de LEDs
  Future<bool> controlarLED(int numeroLed, bool encender) async {
    if (numeroLed == 1) {
      // LED principal usa comandos simples
      return await sendCommand(encender ? ComandosBluetooth.LED_ENCENDER : ComandosBluetooth.LED_APAGAR);
    } else {
      // LEDs adicionales usan formato extendido
      return await sendCommand(ComandosBluetooth.ledComando(numeroLed, encender));
    }
  }

  // üÜï M√âTODOS PARA CONTROLAR TODOS LOS LEDs
  Future<bool> encenderTodosLEDs() async {
    return await sendCommand("ALLON");
  }

  Future<bool> apagarTodosLEDs() async {
    return await sendCommand("ALLOFF");
  }

  // Control de m√∫sica
  Future<bool> reproducirMusica() async {
    return await sendCommand(ComandosBluetooth.MUSICA_PLAY);
  }

  Future<bool> pausarMusica() async {
    return await sendCommand(ComandosBluetooth.MUSICA_PAUSE);
  }

  Future<bool> detenerMusica() async {
    return await sendCommand(ComandosBluetooth.MUSICA_STOP);
  }

  Future<bool> siguienteCancion() async {
    return await sendCommand(ComandosBluetooth.MUSICA_NEXT);
  }

  Future<bool> cancionAnterior() async {
    return await sendCommand(ComandosBluetooth.MUSICA_PREV);
  }

  Future<bool> reproducirCancionEspecifica(int numeroCancion) async {
    return await sendCommand(ComandosBluetooth.reproducirCancion(numeroCancion));
  }

  // Control de humidificador
  Future<bool> controlarHumo(bool encender) async {
    return await sendCommand(encender ? ComandosBluetooth.HUMO_ENCENDER : ComandosBluetooth.HUMO_APAGAR);
  }

  // Obtener estado del dispositivo
  Future<bool> obtenerEstado() async {
    return await sendCommand(ComandosBluetooth.OBTENER_ESTADO);
  }

  /// Manejar llamadas desde el c√≥digo nativo
  Future<void> _handleMethodCall(MethodCall call) async {
    switch (call.method) {
      case 'onDeviceFound':
        _handleDeviceFound(call.arguments);
        break;
      case 'onConnectionStateChanged':
        _handleConnectionStateChanged(call.arguments);
        break;
      case 'onDataReceived':
        _handleDataReceived(call.arguments);
        break;
    }
  }

  void _handleDeviceFound(dynamic arguments) {
    try {
      final Map<String, dynamic> deviceData = Map<String, dynamic>.from(arguments);

      final device = BluetoothDevice(
        name: deviceData['name'] ?? 'Dispositivo desconocido',
        address: deviceData['address'] ?? '',
        type: deviceData['type'] == 'ble' ? BluetoothDeviceType.ble : BluetoothDeviceType.classic,
        rssi: deviceData['rssi'],
        isPaired: deviceData['isPaired'] ?? false,
      );

      // Evitar duplicados
      if (!_discoveredDevices.any((d) => d.address == device.address)) {
        _discoveredDevices.add(device);
        _devicesController.add(List.from(_discoveredDevices));

        // üÜï MOSTRAR si es dispositivo compatible
        bool isTarget = false;
        if (_targetDeviceName != null && _targetDeviceName!.isNotEmpty) {
          isTarget = device.name.toLowerCase().contains(_targetDeviceName!.toLowerCase());
        }

        print('üì± Dispositivo encontrado: ${device.name} ${isTarget ? '(COMPATIBLE)' : ''}');
      }
    } catch (e) {
      print('‚ùå Error procesando dispositivo encontrado: $e');
    }
  }

  void _handleConnectionStateChanged(dynamic arguments) {
    try {
      final String state = arguments as String;
      BluetoothConnectionState newState;

      switch (state) {
        case 'connected':
          newState = BluetoothConnectionState.connected;
          break;
        case 'connecting':
          newState = BluetoothConnectionState.connecting;
          break;
        case 'disconnected':
          newState = BluetoothConnectionState.disconnected;
          _connectedDevice = null;
          break;
        default:
          newState = BluetoothConnectionState.error;
      }

      _updateConnectionState(newState);
    } catch (e) {
      print('‚ùå Error procesando cambio de estado: $e');
    }
  }

  void _handleDataReceived(dynamic arguments) {
    try {
      final String data = arguments as String;
      print('üì• Datos recibidos: $data');
      _dataController.add(data);
    } catch (e) {
      print('‚ùå Error procesando datos recibidos: $e');
    }
  }

  void _updateConnectionState(BluetoothConnectionState newState) {
    if (_currentState != newState) {
      _currentState = newState;
      _connectionStateController.add(newState);
      print('üîÑ Estado de conexi√≥n cambiado a: $newState');
    }
  }

  /// Limpiar recursos
  void dispose() {
    _connectionStateController.close();
    _devicesController.close();
    _dataController.close();
  }
}